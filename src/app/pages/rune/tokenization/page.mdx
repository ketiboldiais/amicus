import MdxLayout from "@/components/mdx-layout";

import {TANGENT_LINE} from "@/components/Calculus"

# Tokenization

<TOC>

- [Introduction](#introduction)
- [Tokens](#tokens)
  - [Utility Token Types](#utility-token-types)
  - [Paired Delimiters](#paired-delimiters)
  - [Unary Delimiters](#unary-delimiters)
  - [Algebraic Operators](#algebraic-operators)

</TOC>

## Introduction
Before we begin implementing, we start with some definitions up front. First, the formal definition of a __symbol__: 

> __*definition*__. A _symbol_, or a _token_, is an atomic unit that a machine can read and write.


For example: ${1,}$ ${\pi,}$ ${\Sigma,}$ ${0,}$ ${x,}$ ${y,}$ ${f,}$ are all symbols. If your computer can highlight it with its cursor—that's almost certainly a symbol, or token. If we put these symbols in a box, we call that box an __alphabet__.  

> __*definition*__. An _alphabet_ is a nonempty and finite set of symbols.

A generic alphabet is often denoted with the Greek letter ${\Sigma.}$

Since symbols are discrete things, we can distinguish between them, which allows us to place them in nice, clear sequences. We call such sequences __strings__.

> __*definition*__. A _string_ over an alphabet is a sequence of symbols from that alphabet.

A generic string is often denoted with the Greek letters ${\sigma}$ or ${\tau.}$ We use the Greek letter ${\varepsilon}$ to denote the empty string—a sequence of symbols of zero length.  The set of all strings over an alphabet ${\Sigma}$ is denoted ${\Sigma^{*}.}$

If we take a bunch of strings and put them in a box, we get a __language__.

> __*definition*__. A _language_ ${L}$ over an alphabet ${\Sigma}$ is a set of strings drawn from ${\Sigma.}$ That is, ${L \subseteq \Sigma^{*}.}$

Keep in mind that this is what a language is from a computer science perspective—it's just a set of strings over a specified alphabet.

## Tokens
Now that we know what a token is, let's start by specifying the tokens we want our language, Rune, to recognize.

We make a distinction between _tokens_ and _token types_. The digits ${1,}$ ${2,}$ ${3,}$ and so on, are all _tokens_. We could read each of these tokens one at a time, but it's clear that certain sequences of tokens (_strings_) are always going to be interpreter the same way. For example, the string ${1393}$ is always an _integer_. Likewise, the string `"while"` is always the keyword `"while"`, which we interpret as marking an iteration procedure.  

Below are all the token types Rune recognizes. Within Rune's source code, these are implemented with a TypeScript enum.

### Utility Token Types
The following token types are used as flags. When encountered during tokenization or parsing, they tell us that something went wrong, and we should halt all further work. 

| Token Type | Lexeme              | Flag                                    |
| ---------- | ------------------- | --------------------------------------- |
| `end`      | `""` (empty string) | End of source code reached.             |
| `error`    | `""` (empty string) | A scanning error occurred.              |
| `empty`    | `""` (empty string) | The empty token, used as a placeholder. |

### Paired Delimiters
These are token types that always come in pairs. For example, the opening parenthesis `"("` and its counterpart, the closing `")"`. If our tokenizer or parser encounters one of these tokens, then we should expect to see its other half.  

| Token Type      | Lexeme |
| --------------- | ------ |
| `left_paren`    | `"("`  |
| `right_paren`   | `")"`  |
| `left_brace`    | `"{"`  |
| `right_brace`   | `"}"`  |
| `left_bracket`  | `"["`  |
| `right_bracket` | `"]"`  |

### Unary Delimiters
Unary delimiters are single, stand-alone token types. They are akin to punctuation—signals that something else follows or precedes, chopping up long token streams into bite-sized, easier-to-digest chunks.

| Token Type  | Lexeme |
| ----------- | ------ |
| `semicolon` | `";"`  |
| `colon`     | `":"`  |
| `dot`       | `"."`  |
| `comma`     | `","`  |

### Algebraic Operators
These token types correspond signify algebraic operations. 


export default function MDXPage({ children }) {
    return <MdxLayout>{children}</MdxLayout>
}